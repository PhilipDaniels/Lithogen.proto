Introduction
============
This guidelines is designed to reduce code duplication when you want to test
an interface that has several concrete implementations. It works by creating
an abstract test class that you instantiate for each concrete type.

This technique should NOT be used to create deep inheritance trees in the test
hierarchy that mimic those in your assembly under test. You should be using mocks
instead to isolate the children in the inheritance hierarchy.


Create projects
===============
MyProject.Tests.Unit - For the unit tests and abstract test classes. Unit tests are fast
and always in RAM. There are no interactions with the external environment (file
system, database, web services).

MyProject.Tests.Integration - For the integration tests. Will need a reference to the
MyProject.Tests.Unit project. Integration tests are slow and/or affect the outside
environment.

Rationale: integration test should be split out from unit tests so that they can
be run separately, yet they will need to share code with the unit tests. This
organization allows that while keeping the number of assemblies down.


Create Files
============
For an interface or abstract class, IFoo, create the following in MyProject.Tests.Unit.

  IFoo_Method1_Base.cs            - Contains the abstract base class.
  (Optional) Concrete_Method1.cs  - Unit tests over a single type.
  (Optional) IFoo_Method1.cs      - Unit tests over several types using [TestFixture].

Class names match the filenames.

You may also create the two files marked 'Optional'in the MyProject.Tests.Integration
project if you have a need to do so. See below for what goes in these files.


The Abstract Base Class (IFoo_Method1_Base.cs)
==============================================
* Mimic the folder/namespace structure of the assembly under test.
* Create an abstract class named for the interface and the method you want to test.
* Create a new abstract class for each method.
* Do not use nested classes. They are confusing and difficult to inherit.
* NUnit test attributes are inherited, so as long as you use [Test] or [TestCase]
  somewhere on the abstract class there is no need to reuse them on the subclasses.
* Make everything public and/or virtual to facilitate testing reuse.
* Avoid use of the suffix "Tests", we know everything is a test by virtue of it being
  in the test assembly.

        public abstract class IFileSystem_CreateDirectory<T> where T : IFileSystem, new()
 
* Add test methods to the abstract class as normal (NUnit test attributes are inherited):

        [Test]
        public virtual void WhenDirectoryIsNull_ThrowsArgumentNullException()
        {
            Assert.Throws<ArgumentNullException>(() => fileSystem.CreateDirectory(null));
        }

        [TestCase("")]
        [TestCase(" ")]
        public virtual void WhenDirectoryNameIsEmptyOrWhitespace_ThrowsArgumentException(string directory)
        {
            Assert.Throws<ArgumentOutOfRangeException>(() => fileSystem.CreateDirectory(directory));
        }

* A setup method is often useful:

        [SetUp]
        public void Setup()
        {
            fileSystem = new T();
        }
        public T fileSystem;


Instantiating the abstract test base using a single concrete type (Concrete_Method1.cs)
=======================================================================================
This method provides good documentation in the NUnit test runner but requires you to
create a type for each subclass. Still, it is not a great deal of code.

    class WindowsFileSystem_CreateDirectory : IFileSystem_CreateDirectory<WindowsFileSystem>
    {
    }

	// Repeat for other types


Instantiating the abstract test base using parameterized types (IFoo_Method1.cs)
================================================================================
This method provides more code reuse but requires slightly more setup. It also
produces an extra level of nesting in the NUnit GUI runner's treeview.

    [TestFixture(typeof(MemoryFileSystem))]
    [TestFixture(typeof(SomethingFileSystem))]
    [TestFixture(typeof(SomethingElseFileSystem))]
    class IFileSystem_CreateDirectory<T> : IFileSystem_CreateDirectory<T>
        where T : IFileSystem, new()
    {
    }


Overriding Behaviour to check for more things
=============================================
Because methods in the abstract class are virtual you can easily check for more
things by writing an override:

    [TestFixture]
    class WindowsFileSystem_CreateDirectory : IFileSystem_CreateDirectory_Base<WindowsFileSystem>
    {
        public override void WhenDirectoryIsNull_ThrowsArgumentNullException()
        {
            base.WhenDirectoryIsNull_ThrowsArgumentNullException();
			Assert.True(fs.SomethingElse);
        }
    }


How [TestFixture] Works
=======================
For a generic type that has *several type parameters* the syntax to *instantiate it
once* is:

    [TestFixture(typeof(firstType), typeof(secondType), typeof(thirdType)]
	class ....


On the other hand, to instantiate a type several times using different types each
time you use several attributes:

    [TestFixture(typeof(A1), typeof(A2), typeof(A3))]
	[TestFixture(typeof(B1), typeof(B2), typeof(B3))]
	class ...

If the type has a constructor that needs arguments, then the syntax is

    [TestFixture(42, "Hello world")]
    class Foo 
    {
	    public Foo(int x, string s) { }
    }

Note that [TestFixture] basically guesses whether it needs to call a constructor
with arguments or use them as type parameters to instantiate the generic. You can
disambiguate (deal with both cases) using one of the the following syntaxes:

   // Type arguments first
   [TestFixture(typeof(A1), typeof(A2), 42, "Hello world")]

   // Using the named TypeArgs argument.
   [TestFixture(42, "Hello world", TypeArgs=new Type[] {typeof(int), typeof(double) } )]

See http://www.nunit.org/index.php?p=testFixture&r=2.5



===============================================================================================

Testing Guidelines
==================
* Name test projects after the assembly they are testing.
    Foo.dll -> Foo.Tests.Units and Foo.Tests.Integration

* Create 1 or 2 test projects for each assembly to be tested
    Foo.dll -> Foo.Tests.Unit = fast running tests
            -> Foo.Tests.Integration = slow running tests or that interact with the outside environment

* Mimic the folder/namespace structure of the AUT (assembly under test) in the test project.

* The general naming convention for a test is "Method_StateUnderTest_ExpectedBehavior" but
  this is modified by use of inner classes (see next item) which effectively promotes
  "Method_" to a class name, thus keeping names shorter and makes test classes easier
  to navigate.

* The [TestFixture] attribute is no longer need on any class.

* For a class Baz, create a BazTests class. DOES NOT NEED TO BE PUBLIC.
** For each method in Baz, create a class within BazTests (including Ctor). 
   THIS ALSO DOES NOT NEED TO BE PUBLIC.
** For each method under test, create a PUBLIC test method named
       StateUnderTest_ExpectedBehavior

   For good names, try starting StateUnderTest with 
           "When" - for referring to parameters
	   and "With" - for referring to state such as properties

	   WhenXXAndYYAndZZ

	   WhenFileNameIsEmptyWithNullBaseDirectory_ThrowsArgumentOutOfRangeException
       WhenCompleted_CreatesEmptyTagCollection
       WithNullProjectPath_ThrowsArgumentNullExpected
	   public void WhenProjectPathIsSetAndViewsDirectoryIsNull_MatchesVisualStudioDefaultsAndIsLowerCase()

   For the ExpectedBehaviour, try
      Throws* - for exceptions
	  ReturnsTrue/False/Null
	  Returns*
	  Succeeds - to simply indicate that the function does not blow up (typically
	             used with functions that return void and have side effects).

* It is nice to Assert.NotNull before checking more specific criteria as it results in a more
  meaningful error message.

* DO NOT use [Explicit] on classes that implement integration tests. These must be
  explicitly selected in the NUnit runner to run, and you have to do it class by class
  which is a pain. Instead follow the organization above, putting them in a separate
  project.

